### 「集训队作业2018」count

-------------------------------

> source：UOJ424

- 什么情况下两个序列满足同构？
- 由最大值，容易想到笛卡尔树：若两个序列的笛卡尔树的形态相同，则同构
- 原题即转换为有多少个不同形态的节点数为 $n$ 的笛卡尔树满足所给要求
- 为了满足题目中所给出的 "如果有多个最大值，取下标最小的" 的要求，规定笛卡尔上的节点 $x$ 满足：$左儿子的值<x的值\&\&右儿子的值\leq x的值$
- 题目中还要求 $1$ 到 $m$ 内的整数都在序列中出现过，考虑什么样的笛卡尔树存在一种分配权值的方法满足这个要求
- 即要求根节点往下走，不存在一种走法，使得往左儿子走的次数 $> m-1$（每往左儿子走一次，相当于权值 $-1$，需要有数可填）
- 现在一棵笛卡尔数就代表了一种满足题目所要求的同构序列，问题成了如何计算不同形态的笛卡尔树

**「solution x10 」生成函数**

（等学了生成函数再补上）

**「solution x20」卡特兰数**

- 考虑将"往左儿子走的次数 $\leq$ $m-1$"进行转换，变为更容易处理的问题

- 多叉树转二叉树：节点 $x$ 的左节点为原树的儿子，右儿子为原树的兄弟
- 现在将笛卡尔树二叉转多叉，往左儿子走的次数转换为了当前树的深度
- 但是会存在转换后够不成一棵树的情况，需要新增加一个虚拟节点为根节点
- 假设虚拟节点的深度为 $0$，现在就是求满足深度 $<=m$ 的树的个数
- 转换为括号序列（进入放"("，离开放")"），需要满足栈内任意时刻的左括号数不超过 $m$ 个（不包括虚拟节点代表的最外层括号在内）
- 统计合法的括号序列个数，转化为卡塔兰数的折线意义（左括号 $+1$，右括号 $-1$），在坐标轴 $xOy$ 上，从 $(0,0)$ 出发，走到 $(0,2n)$ ，不能经过 $y=-1$ 和 $y=m+1$ 这两条直线的方案数

- 可能会进行多次翻折影响答案，分两种情况容斥：
  1. 第一次进行翻折是因为经过直线 $y=-1$
  2. 第一次进行翻折是因为经过直线 $y=m+1$
- 两种情况的计算方式相仿，现在只考虑第一种情况
- 假设当前交替翻折了$i$次（一个来回算两次），终点的位置位于$(2n,x_i)$，对答案则有$(-1)^i*C(2n,\frac{n*2+x_i}{2})$的贡献（$\frac{n*2+x_i}{2}$计算往下要走几步，鸡兔同笼），一变枚举 $i$ 一边计算 $x_i$ 即可

**「solution x21 」代码实现**

```c++
#include<bits/stdc++.h>
using namespace std;
const int Max=1e5;
const long long Mod=998244353;
int n,m;
long long p[Max*2+10]={},inv[Max*2+10]={};
inline long long C(int N,long long M){
	if(N<M||N<0||M<0) return 0;
	return p[N]*inv[M]%Mod*inv[N-M]%Mod;
} 
int main(){
	scanf("%d%d",&n,&m);
	if(n<m) puts("0");
	else{
		p[0]=1; for(int i=1;i<=2*n;i++) p[i]=p[i-1]*i%Mod;
		inv[0]=inv[1]=1; for(int i=2;i<=2*n;i++) inv[i]=inv[Mod%i]*(Mod-Mod/i)%Mod;
		for(int i=1;i<=2*n;i++) inv[i]=inv[i]*inv[i-1]%Mod;
		long long x=0,y=0,Up=m+1,Dn=-1,Upp=m+1,Dnn=-1,ans=C(2*n,n),nU,nD;
		for(int i=1;i<=n;i++){
			if(i&1) x=Up*2-x,Dn=Up*2-Dn,y=Dnn*2-y,Upp=Dnn*2-Upp;//Up,Dn代表第一次在m+1翻折经过i次翻折之后的两条线的位置，Dnn代表第一次在-1翻折经过i次翻折之后的两条线的位置
			else x=Dn*2-x,Up=Dn*2-Up,y=Upp*2-y,Dnn=Upp*2-Dnn;
			ans+=((i&1)?-1:1)*(C(2*n,(2*n+x)/2)+C(2*n,(2*n+y)/2));
			ans=(ans%Mod+Mod)%Mod;
		} 
		printf("%lld\n",ans);
	}
	return 0;
} 
```

